SET(YASM_ROOT_PATHS "$ENV{PROGRAMFILES}/yasm" "$ENV{YASM_DIR}")

FIND_PROGRAM(YASM_EXECUTABLE
  NAMES
    yasm
    yasm-1.2.0-win64.exe
    yasm-1.2.0-win32.exe
  PATHS
    ${YASM_ROOT_PATH}
    ${YASM_ROOT_PATHS}
)

MARK_AS_ADVANCED(YASM_EXECUTABLE)

IF(YASM_EXECUTABLE)
  EXECUTE_PROCESS(COMMAND ${YASM_EXECUTABLE} --version
    OUTPUT_VARIABLE YASM_VERSION
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  STRING(REGEX REPLACE "yasm ([\\.0-9]+).*" "\\1" YASM_VERSION "${YASM_VERSION}")

  IF(YASM_VERSION VERSION_GREATER "1.0")
    MESSAGE(STATUS "Found YASM version ${YASM_VERSION} in ${YASM_EXECUTABLE}")
    SET(YASM_FOUND ON)
  ELSE(YASM_VERSION VERSION_GREATER "1.0")
    MESSAGE(STATUS "Found too old YASM version ${YASM_VERSION} in ${YASM_EXECUTABLE}, disabling ASM")
    SET(YASM_FOUND OFF)
  ENDIF(YASM_VERSION VERSION_GREATER "1.0")
ENDIF(YASM_EXECUTABLE)

# Syntax: SET_TARGET_YASM_LIB(<C++ target> <C++ product> <asm file> [asm file]...)
MACRO(SET_TARGET_YASM_LIB TARGET PRODUCT)
  IF(NOT YASM_FOUND)
    MESSAGE(FATAL_ERROR "Couldn't find YASM to compile ${TARGET}")
  ENDIF(NOT YASM_FOUND)

  SET(_SRC_ASM)
  SET(ASM_DEFINITIONS)
  
  FOREACH(ARG ${ARGN})
    IF(ARG MATCHES "^-")
      LIST(APPEND ASM_DEFINITIONS ${ARG})
    ELSE(ARG MATCHES "^-")
      LIST(APPEND _SRC_ASM ${ARG})
    ENDIF(ARG MATCHES "^-")
  ENDFOREACH(ARG)

  # Define output format suffix
  IF(TARGET_X64)
    SET(ASM_SUFFIX 64)
    SET(ASM_DEFINITIONS -m amd64 ${ASM_DEFINITIONS})
  ELSE(TARGET_X64)
    SET(ASM_SUFFIX 32)
    SET(ASM_DEFINITIONS -m x86 ${ASM_DEFINITIONS})
  ENDIF(TARGET_X64)

  # Define output format
  IF(WIN32)
    SET(ASM_DEFINITIONS -f win${ASM_SUFFIX} ${ASM_DEFINITIONS})
  ELSEIF(APPLE)
    SET(ASM_DEFINITIONS -f macho${ASM_SUFFIX} ${ASM_DEFINITIONS})
  ELSE(WIN32)
    SET(ASM_DEFINITIONS -f elf${ASM_SUFFIX} ${ASM_DEFINITIONS})
  ENDIF(WIN32)

  SET(ASM_DEFINITIONS ${ASM_DEFINITIONS} -I${CMAKE_CURRENT_SOURCE_DIR}/)

  FOREACH(ASM ${_SRC_ASM})
    # Build output filename
    STRING(REPLACE ".asm" ${CMAKE_C_OUTPUT_EXTENSION} OBJ ${ASM})
    GET_FILENAME_COMPONENT(OUTPUT_DIR ${CMAKE_BINARY_DIR} ABSOLUTE)
    STRING(REPLACE ${CMAKE_SOURCE_DIR} ${OUTPUT_DIR} OBJ ${OBJ})

    # Create output directory to avoid error with nmake
    GET_FILENAME_COMPONENT(OUTPUT_DIR ${OBJ} PATH)
    FILE(MAKE_DIRECTORY ${OUTPUT_DIR})

    # Extract path and name from filename
    GET_FILENAME_COMPONENT(INPUT_DIR ${ASM} PATH)
    GET_FILENAME_COMPONENT(BASEFILE ${ASM} NAME)

    # Compile .asm file with nasm
    ADD_CUSTOM_COMMAND(OUTPUT ${OBJ}
      COMMAND ${YASM_EXECUTABLE} ${ASM_DEFINITIONS} -I${INPUT_DIR}/ -o ${OBJ} ${ASM}
      DEPENDS ${ASM}
      COMMENT "Compiling ${BASEFILE}")

    # Append resulting object file to the list
    LIST(APPEND OBJ_ASM ${OBJ})
  ENDFOREACH(ASM)

  SOURCE_GROUP(asm FILES ${_SRC_ASM})
  SOURCE_GROUP(obj FILES ${OBJ_ASM})
  
  # Create a library with all .obj files
  SET_TARGET_LIB(${TARGET}_asm PRIVATE NO_GROUPS ${_SRC_ASM} ${OBJ_ASM})
  SET_TARGET_LABEL(${TARGET}_asm "${PRODUCT} Assembler")

  # Or else we get an error message
  SET_TARGET_PROPERTIES(${TARGET}_asm PROPERTIES LINKER_LANGUAGE C)

  TARGET_LINK_LIBRARIES(${TARGET} ${TARGET}_asm)
ENDMACRO(SET_TARGET_YASM_LIB)
